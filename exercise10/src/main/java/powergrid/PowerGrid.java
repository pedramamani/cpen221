package powergrid;

import java.util.ArrayList;
import java.util.List;

public class PowerGrid {

	/**
	 * Given loads a, b, and c, at three power stations, is it possible to
	 * balance the load using the permitted operation?
	 * 
	 * @param a
	 *            the load at Power Station A, a >= 0
	 * @param b
	 *            the load at Power Station B, b >= 0
	 * @param c
	 *            the load at Power Station C, c >= 0
	 * @return true if load balancing is possible and false otherwise
	 */
	public static boolean canLoadBalance(int a, int b, int c) {
		int sum = a + b + c;
		if(sum % 3 != 0)
			return false;
		else {
			int[] arr = new int[]{a, b, c};
			int[] endArr = new int[]{sum/3, sum/3, sum/3};
			if(areEqual(arr, endArr))
				return true;

			List<int[]> mutations = new ArrayList<>();
			List<int[]> tempList = new ArrayList<>();
			int countMutations = 0;
			mutations.add(arr);

			while(countMutations < mutations.size()) {
				for(int[] mutation : mutations.subList(countMutations, mutations.size())) {
					for(int[] newMutation : mutate(mutation)) {
						if(!isContained(newMutation, mutations) && !isContained(newMutation, tempList)) {
							tempList.add(newMutation);
							if(areEqual(newMutation, endArr))
								return true;
						}
					}
				}
				countMutations = mutations.size();
				mutations.addAll(tempList);
				tempList.clear();
			}

			return false;
		}
	}

	/**
	 * Get an ArrayList of all possible mutations of an array
	 * generated by balancing different elements
	 * @param arr an array
	 * @return an ArrayList of all valid mutations of the array without repetition
	 */
	private static List<int[]> mutate(int[] arr) {
		List<int[]> mutations = new ArrayList<>();
		int[] newMutation;
		mutations.add(arr);

		for(int i = 0; i < arr.length - 1; i++) {
			for(int j = i + 1; j < arr.length; j++) {
				newMutation = balance(arr, i, j);
				if(!isContained(newMutation, mutations))
					mutations.add(newMutation);
			}
		}
		mutations.remove(0);
		return mutations;
	}

	/**
	 * Check if the list contains an array
	 * @param arr
	 * @param list
	 * @return true if the array is contained in the list and false otherwise
	 */
	private static boolean isContained(int[] arr, List<int[]> list){
		for(int[] element : list) {
			if(areEqual(arr, element))
				return true;
		}
		return false;
	}

	/**
	 * Determine if two arrays have the same elements
	 * @param arr1 first array
	 * @param arr2 second array
	 * @return true if the arrays have same elements and false otherwise
	 */
	private static boolean areEqual(int[] arr1, int[] arr2) {
		boolean oneContains = false;
		boolean twoContains = false;

		for(int i2 : arr2) {
			oneContains = false;
			for(int i1 : arr1) {
				if(i1 == i2) {
					oneContains = true;
					break;
				}
			}
			if(!oneContains)
				break;
		}

		for(int i1 : arr1) {
			twoContains = false;
			for(int i2 : arr2) {
				if(i2 == i1) {
					twoContains = true;
					break;
				}
			}
			if(!twoContains)
				break;
		}

		return (oneContains && twoContains);
	}

	/**
	 * Perform the balance operation on two elements of an array
	 * @param arr an array of ints
	 * @param i index of first element to be balanced
	 * @param j index of second element to be balanced
	 * requires the array to have length more than or equal to 2
	 * requires all array elements be positive integers
	 * requires indices i and j to be contained in the array
	 * requires i and j not to be equal
	 * @return an array with its i and j elements balanced
	 */
	private static int[] balance(int[] arr, int i, int j) {
		assert(arr.length >= 2);
		assert(i != j);
		int[] arr_copy = arr.clone();

		if(arr[j] < arr[i]) {
			arr_copy[i] -= arr[j];
			arr_copy[j] *= 2;
		} else if(arr[i] < arr[j]) {
			arr_copy[j] -= arr[i];
			arr_copy[i] *= 2;
		}
		return arr_copy;
    }
}
